{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Namoradinha Project Documentation","text":"<p>Welcome to the Namoradinha project documentation. This site aggregates all the documentation from various parts of the project to provide a comprehensive overview.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<p>The project is organized into several key systems:</p> <ul> <li>Camera System: Handles camera movement, zoom, and effects</li> <li>Environment: Manages the game environment and backgrounds</li> <li>Motion: Controls character and object movement</li> <li>Stage: Handles level composition and layout</li> <li>Visual Background: Manages parallax backgrounds and visual effects</li> </ul>"},{"location":"#documentation-organization","title":"Documentation Organization","text":"<p>Each section of this documentation corresponds to a specific system in the project. The documentation is sourced directly from the README.md files in the project repository, ensuring that it's always up-to-date with the actual code.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with the project, navigate through the sections in the sidebar to learn about each system's functionality and implementation details.</p>"},{"location":"camera/debug/","title":"Debug","text":""},{"location":"camera/debug/#camera-debug-tools","title":"Camera Debug Tools","text":"<p>This folder contains debug tools for the camera system.</p>"},{"location":"camera/debug/#components","title":"Components","text":""},{"location":"camera/debug/#cameradebugtools","title":"CameraDebugTools","text":"<p>A debug component that allows you to freeze/unfreeze camera movement for debugging purposes.</p>"},{"location":"camera/debug/#usage","title":"Usage","text":"<ol> <li>Add the <code>CameraDebugTools.tscn</code> scene as a child of your <code>CameraSystem</code> node</li> <li>Use the <code>C</code> key to toggle camera movement:</li> <li>When disabled: Camera position is frozen at its current position</li> <li>When enabled: Camera resumes normal following behavior</li> <li>Check the console for debug messages</li> </ol>"},{"location":"camera/debug/#features","title":"Features","text":"<ul> <li>Freeze/unfreeze camera movement with <code>C</code> key</li> <li>Preserves camera position when frozen</li> <li>Debug messages in console</li> <li>Easy to add/remove for debugging sessions</li> </ul>"},{"location":"camera/debug/#example","title":"Example","text":"<pre><code># Add to CameraSystem node\nvar debug_tools = load(\"res://camera/debug/CameraDebugTools.tscn\").instantiate()\nadd_child(debug_tools)\n</code></pre>"},{"location":"camera/debug/#debug-keys","title":"Debug Keys","text":"<ul> <li><code>C</code>: Toggle camera movement (freeze/unfreeze) </li> </ul>"},{"location":"camera/overview/","title":"Overview","text":""},{"location":"camera/overview/#camera-system-overview","title":"Camera System Overview","text":"<p>This system manages the game's main camera (<code>Camera2D</code>) and its behavior through a modular subsystem architecture.</p>"},{"location":"camera/overview/#core-components","title":"Core Components","text":"<ul> <li><code>CameraSystem.gd</code>: The main node (<code>Node2D</code>) that orchestrates the camera logic. It initializes subsystems and calls their <code>update</code> methods in <code>_physics_process</code> to ensure synchronization with player movement.</li> <li><code>Camera2D</code> (Child Node): The actual Godot <code>Camera2D</code> node used for rendering.</li> <li><code>CameraConfig.gd</code>: A <code>Resource</code> defining configuration parameters for all camera subsystems. Found in <code>camera/resources/configs/</code>.</li> <li><code>ICameraSubsystem.gd</code>: Interface that all camera subsystems implement, providing a consistent API with <code>initialize()</code>, <code>update()</code>, and <code>set_target()</code> methods.</li> </ul>"},{"location":"camera/overview/#subsystems","title":"Subsystems","text":""},{"location":"camera/overview/#followsystemgd-camerasubsystemsfollow","title":"<code>FollowSystem.gd</code> (<code>camera/subsystems/follow/</code>)","text":"<p>This subsystem is responsible for making the camera follow the player character.</p> <p>Key Logic:</p> <ol> <li>Target Assignment: Receives the player node via <code>set_target</code> when the player spawns.</li> <li>Manual Smoothing: Implements custom smoothing logic within its <code>update</code> method.<ul> <li>The <code>Camera2D</code>'s built-in <code>position_smoothing_enabled</code> is disabled to avoid conflicts.</li> </ul> </li> <li>Horizontal Following: The camera's target X position directly uses the player's <code>global_position.x</code> with optional look-ahead based on velocity.</li> <li>Vertical Following &amp; Locking:<ul> <li>Calculates an <code>ideal_target_y</code> based on whether the player is above a certain height threshold (<code>follow_height_threshold</code>).</li> <li>Vertical Smoothing: Uses <code>_smoothed_target_y</code> to smoothly interpolate towards the <code>ideal_target_y</code> using <code>vertical_smoothing_speed</code>.</li> <li>Look-ahead &amp; Anticipation: Applies additional offsets based on player velocity for smoother following during fast movements.</li> </ul> </li> <li>Camera Smoothing: The camera's position is smoothly interpolated towards the final target position.</li> </ol>"},{"location":"camera/overview/#zoomsystemgd-camerasubsystemszoom","title":"<code>ZoomSystem.gd</code> (<code>camera/subsystems/zoom/</code>)","text":"<p>This subsystem handles dynamic camera zoom based on player movement speed and supports custom zoom effects.</p> <p>Key Logic:</p> <ol> <li>Speed-Based Zoom: Adjusts the camera zoom level based on the player's horizontal speed.</li> <li>Configurable Thresholds: Uses <code>zoom_min_speed_threshold</code> and <code>zoom_max_speed_threshold</code> to determine when to start/stop zooming.</li> <li>Smooth Transitions: Implements smooth interpolation between zoom levels using <code>zoom_smoothing_speed</code>.</li> <li>Custom Zoom Effects: Supports setting custom zoom levels for specific durations, overriding the velocity-based zoom temporarily.</li> </ol>"},{"location":"camera/overview/#slowmotionsystemgd-camerasubsystemsslowmo","title":"<code>SlowMotionSystem.gd</code> (<code>camera/subsystems/slowmo/</code>)","text":"<p>This subsystem manages time scale manipulation for dramatic slow-motion effects.</p> <p>Key Logic:</p> <ol> <li>Time Scale Control: Modifies the engine's time scale to create slow-motion effects.</li> <li>Duration Management: Uses an internal timer to automatically restore normal time scale after a specified duration.</li> <li>Public API: Provides methods to trigger and stop slow motion effects from anywhere in the game.</li> <li>Safety Features: Ensures time scale is properly restored even if the system is destroyed while active.</li> </ol>"},{"location":"camera/overview/#configuration-parameters","title":"Configuration Parameters","text":"<p>The <code>CameraConfig</code> resource provides centralized configuration for all camera subsystems:</p> <ul> <li>Follow System:</li> <li><code>smoothing_speed</code>: General camera follow speed</li> <li><code>vertical_smoothing_speed</code>: Speed for vertical lock transitions</li> <li><code>ground_viewport_ratio</code>: How much of the screen height the 'ground' occupies</li> <li><code>follow_height_threshold</code>: Percentage of screen height above the locked Y before camera follows player Y</li> <li> <p>Look-ahead parameters for anticipating player movement</p> </li> <li> <p>Zoom System:</p> </li> <li><code>min_zoom</code>/<code>max_zoom</code>: Zoom level range</li> <li><code>zoom_min_speed_threshold</code>/<code>zoom_max_speed_threshold</code>: Speed thresholds for zoom changes</li> <li> <p><code>zoom_smoothing_speed</code>: How quickly zoom adjusts</p> </li> <li> <p>Slow Motion System:</p> </li> <li><code>default_slowmo_factor</code>: Default time scale for slow motion</li> <li><code>default_slowmo_duration</code>: Default duration in seconds</li> </ul>"},{"location":"camera/overview/#debug-tools-cameradebug","title":"Debug Tools (<code>camera/debug/</code>)","text":"<p>Contains tools like <code>CameraDebugTools.gd</code> for toggling camera freezing during development (see <code>camera/debug/README.md</code>).</p>"},{"location":"camera/overview/#usage-in-game","title":"Usage in Game","text":"<p>The camera system is included in <code>Game.tscn</code> and initialized in <code>Game.gd</code>. The system automatically connects to the <code>player_spawned</code> signal to set the player as the target for all relevant subsystems.</p>"},{"location":"camera/overview/#dynamic-effects-api","title":"Dynamic Effects API","text":"<p>The camera system provides APIs for triggering context-specific effects:</p>"},{"location":"camera/overview/#slow-motion","title":"Slow Motion","text":"<pre><code># Trigger slow motion with default parameters from config\ncamera_system.trigger_slow_motion()\n\n# Trigger slow motion with custom parameters (duration in seconds, time scale factor)\ncamera_system.trigger_slow_motion(1.5, 0.3)  # 1.5 seconds at 30% speed\n\n# Stop slow motion manually (before duration ends)\ncamera_system.stop_slow_motion()\n\n# Check if slow motion is active\nvar is_active = camera_system.is_slow_motion_active()\n</code></pre>"},{"location":"camera/overview/#custom-zoom","title":"Custom Zoom","text":"<pre><code># Set custom zoom level for a specific duration\ncamera_system.set_custom_zoom(1.5, 2.0)  # Zoom level 1.5 for 2 seconds\n\n# Clear custom zoom and return to velocity-based zooming\ncamera_system.clear_custom_zoom()\n</code></pre> <p>These APIs allow you to create dynamic camera effects for different gameplay situations, such as: - Zooming in for dramatic moments or to focus on details - Zooming out to show more of the environment during special events - Applying slow motion during impactful collisions or special moves</p>"},{"location":"cross-systems/dependency_injection/","title":"Dependency Injection","text":""},{"location":"cross-systems/dependency_injection/#dependency-injection-pattern","title":"Dependency Injection Pattern","text":"<p>This document describes the dependency injection pattern implemented in the game to improve code maintainability, testability, and reduce coupling between components.</p>"},{"location":"cross-systems/dependency_injection/#overview","title":"Overview","text":"<p>Dependency injection is a design pattern where dependencies are \"injected\" into objects rather than having objects create or look up their dependencies. This approach:</p> <ul> <li>Reduces coupling between components</li> <li>Makes testing easier by allowing mock dependencies</li> <li>Improves code reusability</li> <li>Makes dependencies explicit</li> </ul>"},{"location":"cross-systems/dependency_injection/#implementation","title":"Implementation","text":""},{"location":"cross-systems/dependency_injection/#before-refactoring","title":"Before Refactoring","text":"<p>Previously, components like PlayerCharacter and PlayerSpawner would directly look up their dependencies using hard-coded paths:</p> <pre><code># Hard-coded path lookup\nmotion_system = get_node_or_null(\"/root/Game/MotionSystem\")\n</code></pre> <p>This approach created tight coupling and made testing difficult.</p>"},{"location":"cross-systems/dependency_injection/#after-refactoring","title":"After Refactoring","text":"<p>Now, dependencies are passed explicitly:</p> <ol> <li>Setter Methods: Components expose setter methods to receive dependencies:</li> </ol> <pre><code># In PlayerCharacter.gd\nfunc set_motion_system(system) -&gt; void:\n    motion_system = system\n    # Initialize with the dependency\n    if motion_system:\n        entity_id = get_instance_id()\n</code></pre> <ol> <li>Dependency Passing: Game.gd passes dependencies to components:</li> </ol> <pre><code># In Game.gd\nfunc _ready():\n    # Initialize motion system\n    initialize_motion_system()\n\n    # Pass motion system reference to player spawner\n    player_spawner.set_motion_system(motion_system)\n</code></pre> <ol> <li>Cascading Dependencies: Components pass dependencies to their children:</li> </ol> <pre><code># In PlayerSpawner.gd\nfunc spawn_player():\n    # ...\n    player_instance = scene_to_use.instantiate()\n\n    # Set motion system reference before adding to scene tree\n    if motion_system and player_instance.has_method(\"set_motion_system\"):\n        player_instance.set_motion_system(motion_system)\n</code></pre>"},{"location":"cross-systems/dependency_injection/#benefits","title":"Benefits","text":"<ol> <li>Testability: Components can be tested in isolation by injecting mock dependencies.</li> <li>Flexibility: Components can be reused in different contexts with different dependencies.</li> <li>Explicit Dependencies: Dependencies are clearly visible in the code.</li> <li>Reduced Coupling: Components don't need to know where their dependencies come from.</li> </ol>"},{"location":"cross-systems/dependency_injection/#best-practices","title":"Best Practices","text":"<ol> <li>Use Setter Methods: Provide setter methods for dependencies.</li> <li>Set Dependencies Early: Set dependencies before they're needed, ideally before adding nodes to the scene tree.</li> <li>Check for Missing Dependencies: Add checks and appropriate error messages for missing dependencies.</li> <li>Cascade Dependencies: Pass dependencies down to child components.</li> <li>Type Hints: Use type hints to make dependencies clear (e.g., <code>func set_motion_system(system: MotionSystem) -&gt; void</code>).</li> </ol>"},{"location":"cross-systems/dependency_injection/#future-improvements","title":"Future Improvements","text":"<ol> <li>Constructor Injection: Consider using <code>_init()</code> for dependency injection where appropriate.</li> <li>Dependency Containers: For more complex applications, implement a dependency container to manage dependencies.</li> <li>Interface-Based Dependencies: Define interfaces for dependencies to further reduce coupling.</li> </ol>"},{"location":"cross-systems/effects/","title":"Effects","text":""},{"location":"cross-systems/effects/#effects","title":"Effects","text":"<p>This directory contains various effect implementations for the game.</p>"},{"location":"cross-systems/effects/#structure","title":"Structure","text":"<ul> <li>visual_effects/: Visual feedback effects (particles, animations, etc.)</li> <li>audio_effects/: Sound effects (to be implemented)</li> <li>game_effects/: Game-wide effects like slow motion, screen shake, etc. (to be implemented)</li> </ul>"},{"location":"cross-systems/effects/#visual-effects","title":"Visual Effects","text":"<p>Visual effects are purely cosmetic and provide visual feedback to the player. They don't affect gameplay mechanics directly.</p> <p>Examples: - BoostEffect: Particle effect shown when a boost is applied</p>"},{"location":"cross-systems/effects/#audio-effects","title":"Audio Effects","text":"<p>Audio effects provide sound feedback to the player. This directory will be implemented in the future.</p>"},{"location":"cross-systems/effects/#game-effects","title":"Game Effects","text":"<p>Game effects affect the entire game state, such as slow motion or screen effects. This directory will be implemented in the future.</p>"},{"location":"cross-systems/effects/#usage","title":"Usage","text":"<p>Effects are typically instantiated and attached to game objects that need them:</p> <p>```gdscript</p>"},{"location":"cross-systems/effects/#example-creating-a-boost-effect","title":"Example: Creating a boost effect","text":"<p>var boost_effect = load(\"res://scripts/effects/visual_effects/BoostEffect.gd\").new() add_child(boost_effect) boost_effect.show_effect(direction, \"manual_air\")</p>"},{"location":"environment/overview/","title":"Overview","text":""},{"location":"environment/overview/#environment-system","title":"Environment System","text":"<p>The Environment System manages the visual aspects of the game world, including backgrounds, effects, and ground visuals. It coordinates multiple visual managers and handles theme/biome transitions.</p>"},{"location":"environment/overview/#architecture","title":"Architecture","text":"<p>The Environment System follows a manager-based architecture:</p> <pre><code>graph TD\n    EnvironmentSystem[EnvironmentSystem] --&gt; EffectsManager\n    EnvironmentSystem[EnvironmentSystem] --&gt; GroundVisualManager\n    EnvironmentSystem --&gt; SharedGroundManager\n\n    EnvironmentSystem --&gt; ThemeDatabase\n    ThemeDatabase --&gt; EnvironmentTheme\n\n    EnvironmentSystem -.-&gt; MotionProfileResolver\n\n    GlobalSignals -.-&gt;|stage_loaded| EnvironmentSystem\n    GlobalSignals -.-&gt;|theme_changed| EnvironmentSystem\n    GlobalSignals -.-&gt;|biome_changed| EnvironmentSystem</code></pre>"},{"location":"environment/overview/#core-components","title":"Core Components","text":"<ol> <li>EnvironmentSystem (<code>EnvironmentSystem.gd</code>): </li> <li>Central coordinator for all environment-related functionality</li> <li>Manages theme and biome changes</li> <li> <p>Coordinates visual transitions between themes</p> </li> <li> <p>Visual Managers:</p> </li> <li>EffectsManager: Manages visual effects like particles and animations</li> <li> <p>GroundVisualManager: Controls the appearance of ground surfaces</p> </li> <li> <p>Ground Management:</p> </li> <li>SharedGroundManager: Creates and manages a shared ground for the entire level</li> <li>GroundVisualManager: Handles visual representation of ground surfaces</li> <li> <p>Note: Ground visuals are now primarily handled by the chunk system in StageCompositionSystem, which has replaced the old GroundManager functionality</p> </li> <li> <p>Configuration:</p> </li> <li>ThemeDatabase: Collection of all available environment themes</li> <li>EnvironmentTheme: Defines visual properties for a specific theme</li> <li>StageConfig: Links themes to stages</li> </ol>"},{"location":"environment/overview/#theme-system","title":"Theme System","text":"<p>The Environment System uses a theme-based approach to visual styling:</p> <ol> <li>Themes: Define the overall visual style (colors, textures, effects)</li> <li>Stored as resources in <code>resources/environment/themes/</code></li> <li> <p>Each theme has a unique ID (e.g., \"default\", \"ice\", \"desert\")</p> </li> <li> <p>Biomes: Define the physical properties of the environment</p> </li> <li>Affect ground physics (friction, bounce, etc.)</li> <li> <p>Linked to ground physics configs in <code>resources/motion/profiles/ground/</code></p> </li> <li> <p>Theme Application:</p> </li> <li>When a theme is applied, it's distributed to all visual managers</li> <li>Each manager handles its specific visual elements</li> <li>Transitions are coordinated to ensure smooth visual changes</li> </ol>"},{"location":"environment/overview/#biome-system-architecture","title":"Biome System Architecture","text":"<p>The biome system is designed with a modular, expandable architecture:</p>"},{"location":"environment/overview/#current-implementation","title":"Current Implementation","text":"<p>Currently, biomes primarily affect ground physics through <code>GroundPhysicsConfig</code> resources: - Resources are stored as <code>resources/motion/profiles/ground/{biome_id}_ground.tres</code> - Each biome has specific ground physics properties (friction, bounce, etc.) - The <code>_ground</code> suffix in filenames indicates these resources specifically control ground physics</p> <pre><code>graph TD\n    A[EnvironmentSystem] --&gt;|change_biome| B[MotionProfileResolver]\n    B --&gt;|loads| C[\"{biome_id}_ground.tres\"]\n    C --&gt;|applies to| D[Player Physics]</code></pre>"},{"location":"environment/overview/#planned-expansion","title":"Planned Expansion","text":"<p>The biome system is designed to expand beyond ground physics in the future:</p> <ol> <li>Air Physics: Future air-related configs will define biome-specific air properties</li> <li>Referenced in code comments as <code>_air_config</code></li> <li> <p>Would likely handle wind effects and air movement</p> </li> <li> <p>Environmental Forces: As mentioned in the Motion System README</p> </li> <li>Environmental forces like wind and currents</li> <li> <p>Biome-specific environmental effects</p> </li> <li> <p>Theme Integration: </p> </li> <li>Comment in EnvironmentSystem.gd: \"In the future, biomes might affect theme selection\"</li> </ol>"},{"location":"environment/overview/#interaction-with-equipment-and-traits","title":"Interaction with Equipment and Traits","text":"<p>The Motion System's layered physics resolution allows biomes to interact with player equipment and traits:</p> <pre><code>graph TD\n    A[MotionProfileResolver] --&gt; B[Layer 4: Global Physics Config]\n    A --&gt; C[Layer 3: Biome/Ground Physics]\n    A --&gt; D[Layer 2: Equipment + Traits]\n    A --&gt; E[Layer 1: Temporary Modifiers]</code></pre> <p>This architecture enables gameplay mechanics like: - Equipment that counters specific biome challenges (e.g., ice boots in a slippery biome) - Traits that provide advantages in certain environments - Specialized gear for different biome types</p> <p>For more details on this interaction, see the \"Physics Resolution Architecture\" section in the Motion System README.</p>"},{"location":"environment/overview/#integration-with-physics-and-stage-systems","title":"Integration with Physics and Stage Systems","text":"<p>The Environment System integrates with other systems in several ways:</p>"},{"location":"environment/overview/#physics-integration","title":"Physics Integration","text":"<p>The Environment System integrates with the physics system through the <code>MotionProfileResolver</code>:</p> <ol> <li>When a biome changes, the Environment System updates the ground physics configuration in the <code>MotionProfileResolver</code></li> <li>This affects how the player character interacts with the environment (friction, bounce, etc.)</li> </ol>"},{"location":"environment/overview/#stage-composition-integration","title":"Stage Composition Integration","text":"<p>The Environment System works alongside the Stage Composition System:</p> <ol> <li>Division of Responsibilities:</li> <li>Environment System: Handles theme application, visual transitions, and biome physics</li> <li> <p>Stage Composition System: Handles chunk generation, content distribution, and ground structure</p> </li> <li> <p>Architectural Evolution:</p> </li> <li>The old GroundManager functionality has been replaced by the chunk system in StageCompositionSystem</li> <li>GroundVisualManager now focuses on visual representation rather than structural management</li> <li> <p>SharedGroundManager provides a simplified ground collision layer for the entire level</p> </li> <li> <p>Communication Flow:</p> </li> <li>Stage events trigger environment changes via GlobalSignals</li> <li>Environment changes (like biome updates) affect stage generation parameters</li> </ol>"},{"location":"environment/overview/#usage","title":"Usage","text":""},{"location":"environment/overview/#applying-themes","title":"Applying Themes","text":"<p>Themes can be applied in several ways:</p> <ol> <li> <p>Direct Method Call: <pre><code>environment_system.apply_theme_by_id(\"ice\")\n</code></pre></p> </li> <li> <p>Via Global Signal: <pre><code>GlobalSignals.theme_changed.emit(\"desert\")\n</code></pre></p> </li> <li> <p>Via Stage Config: <pre><code>var config = StageConfig.new()\nconfig.theme_id = \"jungle\"\nGlobalSignals.stage_loaded.emit(config)\n</code></pre></p> </li> </ol>"},{"location":"environment/overview/#changing-biomes","title":"Changing Biomes","text":"<p>Biomes can be changed using the global signal:</p> <pre><code>GlobalSignals.biome_changed.emit(\"ice\")\n</code></pre>"},{"location":"environment/overview/#creating-custom-themes","title":"Creating Custom Themes","text":"<p>To create a custom theme:</p> <ol> <li>Create a new resource file inheriting from <code>EnvironmentTheme</code></li> <li>Set the theme properties (colors, textures, etc.)</li> <li>Add the theme to the <code>ThemeDatabase</code></li> </ol> <pre><code>var theme = EnvironmentTheme.new()\ntheme.theme_id = \"custom_theme\"\ntheme.ground_texture = preload(\"res://path/to/ground.png\")\n# Set other properties...\n\nvar theme_database = preload(\"res://resources/environment/theme_database.tres\")\ntheme_database.add_theme(theme)\n</code></pre>"},{"location":"environment/overview/#transitions","title":"Transitions","text":"<p>The Environment System handles smooth transitions between themes:</p> <ol> <li>When a new theme is applied, all managers begin their transitions</li> <li>Each manager signals when its transition is complete</li> <li>The Environment System emits a <code>transition_completed</code> signal when all transitions are done</li> </ol> <p>This allows for coordinated visual changes across all environment elements.</p>"},{"location":"environment/overview/#debugging","title":"Debugging","text":"<p>The Environment System includes debugging functionality:</p> <ol> <li>Debug Overlay: In debug builds, an overlay can be shown to display current theme and biome information</li> <li>Debug Theme Switching: In debug builds, pressing keys 1-2 switches between themes</li> </ol>"},{"location":"environment/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Theme Consistency: Ensure all visual elements (background, ground, effects) are consistent within a theme</li> <li>Biome-Theme Alignment: Match biome physics properties with theme visuals for a cohesive experience</li> <li>Transition Timing: Keep transitions short and smooth to avoid disrupting gameplay</li> <li>Resource Management: Preload theme resources to avoid loading hitches during gameplay</li> <li>Fallback Handling: Provide fallback visuals in case theme resources are missing</li> </ol>"},{"location":"motion/boost_system/","title":"Boost System","text":""},{"location":"motion/boost_system/#boost-system","title":"Boost System","text":"<p>A modular system for applying boosts to entities during gameplay.</p>"},{"location":"motion/boost_system/#overview","title":"Overview","text":"<p>The Boost System allows entities to receive velocity changes during gameplay based on different boost types. The system is designed to be extensible, allowing for various boost types with different behaviors.</p>"},{"location":"motion/boost_system/#core-components","title":"Core Components","text":"<ul> <li>BoostSystem: Main entry point implementing the IMotionSubsystem interface</li> <li>BoostTypeRegistry: Manages registration of different boost types</li> <li>BoostCalculator: Handles boost vector calculations</li> <li>IBoostType: Interface for all boost types</li> <li>AirBoostType: Implementation of the Manual Air Boost type</li> </ul>"},{"location":"motion/boost_system/#data-structures","title":"Data Structures","text":"<ul> <li>BoostContext: Input data for boost calculations (includes current motion state and the resolved <code>motion_profile</code> from <code>MotionProfileResolver</code>).</li> <li>BoostOutcome: Output data with calculation results.</li> </ul>"},{"location":"motion/boost_system/#manual-air-boost","title":"Manual Air Boost","text":"<p>The Manual Air Boost is a player-triggered boost that can only be used while airborne. It provides a directional motion change based on the player's vertical movement:</p> <ul> <li>When rising: Applies an upward-forward boost (orange-yellow visual effect)</li> <li>When falling: Applies a downward-forward boost (orange-yellow visual effect)</li> </ul>"},{"location":"motion/boost_system/#visual-effects","title":"Visual Effects","text":"<p>Note: Visual effects have been temporarily disabled to fix a flickering issue.</p> <p>The system includes code for visual effects, but they are currently not being used:</p> <ul> <li>Manual Air Boost: (Disabled) Orange-yellow particles with a matching trail</li> <li>Environmental Boost (future): (Disabled) Green particles with a matching trail</li> <li>Mega Boost (future): (Disabled) Purple particles with a matching trail</li> </ul> <p>If visual effects need to be re-enabled in the future:</p> <ol> <li>Restore the calls to <code>_create_boost_effect()</code> in <code>_ready()</code> and <code>_show_boost_effect()</code> in <code>_try_boost()</code> in PlayerCharacter.gd</li> <li>Fix the flickering issue that occurs on the first boost application</li> </ol>"},{"location":"motion/boost_system/#setup-instructions","title":"Setup Instructions","text":""},{"location":"motion/boost_system/#1-add-input-mapping","title":"1. Add Input Mapping","text":"<p>Before using the Manual Air Boost, you need to add an input action in the Godot project settings:</p> <ol> <li>Open the Godot editor</li> <li>Go to Project &gt; Project Settings</li> <li>Select the \"Input Map\" tab</li> <li>Add a new action called \"boost\"</li> <li>Assign a key (e.g., Space) to this action</li> </ol> <p></p>"},{"location":"motion/boost_system/#2-motion-profile-configuration","title":"2. Motion Profile Configuration","text":"<p>Boost calculations utilize parameters resolved by the <code>MotionProfileResolver</code>. Parameters relevant to boosts (like <code>manual_air_boost_falling_strength</code>, <code>velocity_modifier</code>) are primarily defined in the global <code>PhysicsConfig</code> (<code>default_physics.tres</code>) and potentially overridden by other configuration sources (like <code>GroundPhysicsConfig</code>) before being included in the final resolved profile.</p> <p>The <code>BoostSystem</code> receives the resolved <code>motion_profile</code> dictionary via the <code>BoostContext</code> object during the <code>try_apply_boost</code> call. Specific boost type implementations (<code>IBoostType</code>) and the <code>BoostCalculator</code> access parameters from this dictionary.</p> <p>Example access within an <code>IBoostType</code> implementation (like <code>AirBoostType.gd</code>): <pre><code>func calculate_boost_vector(boost_context: BoostContext) -&gt; Vector2:\n    # Access the resolved motion profile from the context\n    var motion_profile = boost_context.motion_profile\n    var boost_strength = 0.0\n    var boost_angle_degrees = 0.0\n\n    if boost_context.is_rising:\n        # Get values from motion_profile (which includes PhysicsConfig values)\n        boost_strength = motion_profile.get(\"manual_air_boost_rising_strength\")\n        boost_angle_degrees = motion_profile.get(\"manual_air_boost_rising_angle\")\n    else:\n        boost_strength = motion_profile.get(\"manual_air_boost_falling_strength\")\n        boost_angle_degrees = motion_profile.get(\"manual_air_boost_falling_angle\")\n\n    # ... calculate vector ...\n\n    # Apply general velocity modifier if present\n    var velocity_modifier = motion_profile.get(\"velocity_modifier\", 1.0)\n    boost_vector *= velocity_modifier\n\n    return boost_vector\n</code></pre></p> <p>This ensures boosts use parameters defined centrally in <code>PhysicsConfig</code> but can still be influenced by context (ground type, traits, etc.) via the <code>MotionProfileResolver</code>.</p>"},{"location":"motion/boost_system/#usage","title":"Usage","text":"<p>The PlayerCharacter class now has input handling for the Manual Air Boost. When the player presses the \"boost\" key (Space by default) while airborne, it will:</p> <ol> <li>Check if the player is in a valid state for boosting</li> <li>Call the BoostSystem's <code>try_apply_boost</code> method with the current state</li> <li>Apply the resulting velocity if successful</li> </ol>"},{"location":"motion/boost_system/#extending-with-new-boost-types","title":"Extending with New Boost Types","text":"<p>To add a new boost type:</p> <ol> <li>Create a new class in <code>scripts/boosts/</code> that implements the IBoostType interface</li> <li>Register it with the BoostTypeRegistry in BoostSystem's <code>_init</code> method</li> <li>Implement the activation mechanism appropriate for that boost type</li> </ol> <p>Different boost types can have different activation mechanisms: - Manual boosts: Triggered by player input - Passive/Buff boosts: Triggered automatically based on game state - Environmental boosts: Triggered by collision with objects - Mega boosts: Triggered by special conditions</p>"},{"location":"motion/bounce_system/","title":"Bounce System","text":""},{"location":"motion/bounce_system/#bounce-system-rewritten","title":"Bounce System (Rewritten)","text":"<p>This document describes the rewritten Bounce System, designed to be stateless, reactive, and decoupled, adhering to the principles outlined in the original behavioural summary.</p>"},{"location":"motion/bounce_system/#core-philosophy","title":"Core Philosophy","text":"<ul> <li>Reactive Calculator: The system acts only when triggered by a collision event via its <code>get_collision_modifiers</code> method. It does not manage ongoing player state.</li> <li>Stateless Calculation: Each bounce calculation is independent, based solely on the context provided at the moment of impact. It does not track bounce history internally.</li> <li>Decoupling: Interaction occurs exclusively through well-defined data contract classes passed into the calculation method.</li> <li>Externalized Modifiers: Permanent modifiers are received via the input context. Dynamic modifiers (boosts, wind) are expected to have already altered the player's motion state before the collision context is provided to this system.</li> </ul>"},{"location":"motion/bounce_system/#interaction-flow","title":"Interaction Flow","text":"<ol> <li>Collision Detection: An external system (e.g., <code>MotionSystemCore</code>, Physics Engine) detects a relevant collision (e.g., player hitting the ground).</li> <li>Context Gathering: The external system gathers all necessary information:<ul> <li>Player's motion state just before impact (<code>IncomingMotionState</code>).</li> <li>Collision details like normal (<code>ImpactSurfaceData</code>).</li> <li>Player's permanent bounce profile (from traits, equipment - <code>PlayerBounceProfile</code>).</li> <li>Current gravity affecting the player.</li> <li>The <code>player_node</code> itself (needed for profile resolution).</li> </ul> </li> <li>Context Object Creation: The external system creates a <code>CollisionContext</code> object containing the gathered data.</li> <li>Method Call: The external system calls <code>BounceSystem.get_collision_modifiers(context: CollisionContext)</code>.</li> <li>Internal Calculation:<ul> <li><code>BounceSystem</code> validates the context.</li> <li><code>BounceSystem</code> uses the <code>MotionProfileResolver</code> (passed during initialization) to resolve the current <code>motion_profile</code> for the <code>player_node</code>.</li> <li><code>BounceSystem</code> retrieves the <code>PhysicsConfig</code> instance (injected by <code>MotionSystemCore</code> or uses a default).</li> <li><code>BounceSystem</code> checks if it's a floor collision.</li> <li><code>BounceSystem</code> calls <code>BounceCalculator.calculate(context: CollisionContext, resolved_profile: Dictionary, physics_rules: PhysicsConfig)</code>.</li> <li><code>BounceCalculator</code> performs the physics calculation using data from the context, the resolved profile, and the physics rules.</li> <li><code>BounceCalculator</code> determines if the bounce results in continued bouncing, sliding, or stopping based on thresholds from <code>physics_rules</code> or <code>resolved_profile</code>.</li> <li><code>BounceCalculator</code> returns a <code>BounceOutcome</code> object.</li> </ul> </li> <li>Modifier Generation: <code>BounceSystem</code> receives the <code>BounceOutcome</code> and generates a <code>MotionModifier</code> to apply the resulting <code>new_velocity</code>.</li> <li>Return: <code>BounceSystem</code> returns an array containing the single velocity <code>MotionModifier</code>.</li> <li>Modifier Application: The external system (<code>MotionSystemCore</code>) applies the returned modifier to the player's state.</li> </ol>"},{"location":"motion/bounce_system/#data-contracts","title":"Data Contracts","text":"<p>These classes define the data passed to and returned from the system:</p> <ul> <li><code>CollisionContext</code> (<code>../data/CollisionContext.gd</code>): Input object containing:<ul> <li><code>player_node: Node</code> (Required for profile resolution)</li> <li><code>incoming_motion_state: IncomingMotionState</code></li> <li><code>impact_surface_data: ImpactSurfaceData</code> (Provides collision normal, surface elasticity/friction from <code>CollisionMaterialSystem</code>)</li> <li><code>player_bounce_profile: PlayerBounceProfile</code> (Contains player-specific multipliers/adjustments)</li> <li><code>current_gravity: Vector2</code></li> <li><code>generate_debug_data: bool</code></li> </ul> </li> <li><code>BounceOutcome</code> (<code>data/BounceOutcome.gd</code>): Output object containing:<ul> <li><code>new_velocity: Vector2</code></li> <li><code>termination_state: String</code> (Constants: <code>STATE_BOUNCING</code>, <code>STATE_SLIDING</code>, <code>STATE_STOPPED</code>)</li> <li><code>debug_data: BounceDebugData</code> (Optional, for debug builds)</li> </ul> </li> <li>Supporting Data Classes:<ul> <li><code>IncomingMotionState</code> (<code>data/IncomingMotionState.gd</code>)</li> <li><code>ImpactSurfaceData</code> (<code>../data/ImpactSurfaceData.gd</code>) - Note: Moved to <code>scripts/motion/data/</code></li> <li><code>PlayerBounceProfile</code> (<code>data/PlayerBounceProfile.gd</code>)</li> <li><code>BounceDebugData</code> (<code>data/BounceDebugData.gd</code>)</li> </ul> </li> </ul>"},{"location":"motion/bounce_system/#components","title":"Components","text":"<ul> <li><code>BounceSystem</code> (<code>BounceSystem.gd</code>):<ul> <li>Implements <code>IMotionSubsystem</code>.</li> <li>Orchestrates the process: receives context, resolves profile, gets physics rules, calls calculator, creates modifier.</li> <li>Handles floor detection logic.</li> </ul> </li> <li><code>BounceCalculator</code> (<code>components/BounceCalculator.gd</code>):<ul> <li>Contains the pure, stateless physics calculation logic.</li> <li>Takes <code>CollisionContext</code>, <code>resolved_profile</code>, and <code>physics_rules</code> as input, returns <code>BounceOutcome</code>.</li> <li>Applies elasticity, friction, profile modifiers.</li> <li>Uses thresholds from <code>physics_rules</code> (or <code>resolved_profile</code> overrides) to determine termination state (bouncing, sliding, stopped).</li> </ul> </li> </ul>"},{"location":"motion/bounce_system/#testing","title":"Testing","text":"<p>The system is tested via <code>test_bounce_system.gd</code>, which directly instantiates <code>BounceSystem</code> and provides mock <code>CollisionContext</code> objects to verify various scenarios, including basic bounces, modifier effects, termination, and full sequence simulation.</p> <p>Note: There appears to be a persistent, misleading GDScript parser error (\"Assignment is not allowed inside an expression\") reported by Godot v4.4.1.stable when running the test script via the command line, even though the code syntax is valid. The tests should function correctly despite this erroneous parser message.</p>"},{"location":"motion/bounce_system/#integration-requirements","title":"Integration Requirements","text":"<p>The calling system (<code>MotionSystemCore</code>) must be responsible for: 1.  Detecting relevant collisions. 2.  Gathering all necessary data (motion state, collision details, player profile, gravity, and the player_node). 3.  Constructing the <code>CollisionContext</code> object accurately. 4.  Ensuring the <code>BounceSystem</code> has been initialized with the <code>MotionProfileResolver</code> and <code>PhysicsConfig</code> (via <code>MotionSystemCore</code>). 5.  Calling <code>BounceSystem.get_collision_modifiers</code> with the context object. 6.  Applying the returned <code>MotionModifier</code>.</p>"},{"location":"motion/bounce_system/#interaction-with-characterbody2d-and-move_and_slide","title":"Interaction with CharacterBody2D and <code>move_and_slide()</code>","text":"<p>A key consideration when implementing custom bounce logic for a <code>CharacterBody2D</code> is the timing relative to the built-in <code>move_and_slide()</code> function.</p> <p>Problem Encountered:</p> <p>Initially, the custom bounce logic was triggered based on the <code>is_on_floor()</code> check within <code>_physics_process</code>. However, when the character hit the floor with high velocity (e.g., after a launch), the <code>move_and_slide()</code> function, executed before the <code>is_on_floor()</code> check in the next frame, would handle the collision first. Its default behavior often clamps or significantly reduces the vertical velocity upon impact. Consequently, when our custom <code>_handle_floor_collision</code> (or equivalent logic) ran in the subsequent frame, it received an already-dampened velocity, leading to unexpectedly small bounces despite high initial impact speeds.</p> <p>Solution Implemented:</p> <p>To ensure the custom bounce logic uses the character's velocity before <code>move_and_slide</code> modifies it upon impact, the approach was changed:</p> <ol> <li>The character's velocity is stored before calling <code>move_and_slide()</code>.</li> <li><code>move_and_slide()</code> is called.</li> <li>Immediately after <code>move_and_slide()</code>, <code>get_slide_collision_count()</code> and <code>get_slide_collision(i)</code> are used to check for collisions that occurred during that movement step.</li> <li>If a floor collision is detected via <code>get_slide_collision()</code>, the custom collision resolution logic (which calls the <code>BounceSystem</code>) is invoked within the same frame.</li> <li>Crucially, the <code>collision_info</code> passed to the <code>MotionSystem</code> uses the velocity stored before <code>move_and_slide()</code>, along with the collision details (normal, etc.) obtained from the <code>KinematicCollision2D</code> object.</li> <li>The resulting velocity calculated by the <code>BounceSystem</code> (and potentially other subsystems) is then applied directly, overwriting any modifications made internally by <code>move_and_slide()</code>.</li> </ol> <p>This ensures that the bounce calculation accurately reflects the pre-impact velocity, allowing for high-energy bounces consistent with the launch parameters. The previous method of checking <code>is_on_floor()</code> in the next frame was removed to avoid redundant processing.</p>"},{"location":"motion/collision_material_system/","title":"Collision Material System","text":""},{"location":"motion/collision_material_system/#collisionmaterialsystem","title":"CollisionMaterialSystem","text":"<p>A subsystem for the MotionSystem that provides material-specific physics properties based on collision context.</p>"},{"location":"motion/collision_material_system/#overview","title":"Overview","text":"<p>The CollisionMaterialSystem acts as a central repository and lookup service for surface material properties (friction, bounce, sound). It reads these properties directly from the global <code>PhysicsConfig</code> resource (<code>default_physics.tres</code>) during initialization.</p> <p>When an entity collides with something, other systems (like <code>CollisionMotionResolver</code>) determine the type of material involved (e.g., \"ice\", \"mud\", \"default\"). They then query this system to get the physics parameters associated with that material type.</p>"},{"location":"motion/collision_material_system/#features","title":"Features","text":"<ul> <li>Stores physics properties (friction, bounce, sound) associated with different material names (\"default\", \"ice\", \"mud\", \"rubber\").</li> <li>Loads these properties directly from the <code>PhysicsConfig</code> resource injected by <code>MotionSystemCore</code>.</li> <li>Provides a method (<code>get_material_properties</code>) to retrieve the properties dictionary for a given material name.</li> </ul>"},{"location":"motion/collision_material_system/#integration-with-motionsystem","title":"Integration with MotionSystem","text":"<p>The CollisionMaterialSystem implements the <code>IMotionSubsystem</code> interface and is registered with the <code>MotionSystemCore</code>.</p> <ul> <li>Initialization: <code>MotionSystemCore</code> calls <code>set_physics_config(config)</code> on this system, passing the loaded <code>PhysicsConfig</code> resource.</li> <li>Property Loading: The <code>set_physics_config</code> method triggers <code>_update_materials_from_config</code>, which reads properties like <code>default_material_friction</code>, <code>ice_material_bounce</code>, etc., from the <code>PhysicsConfig</code> and stores them internally in the <code>_registered_materials</code> dictionary.</li> <li>Usage: Other systems, primarily <code>CollisionMotionResolver</code>, query this system using <code>get_material_properties(material_type)</code> to get the friction and bounce values needed to create <code>ImpactSurfaceData</code> for collision calculations.</li> </ul>"},{"location":"motion/collision_material_system/#usage","title":"Usage","text":"<ol> <li> <p>Define Properties in PhysicsConfig: Ensure all material properties are defined in <code>PhysicsConfig.gd</code> (<code>@export var</code>) and have corresponding values set in <code>resources/physics/default_physics.tres</code>.     <pre><code># In PhysicsConfig.gd\n@export var default_material_friction: float = 0.3\n@export var default_material_bounce: float = 0.8\n@export var ice_material_friction: float = 0.05\n# ... etc ...\n\n# In default_physics.tres\n[resource]\nscript = ExtResource(\"...\")\ndefault_material_friction = 0.3\ndefault_material_bounce = 0.8\nice_material_friction = 0.05\n# ... etc ...\n</code></pre></p> </li> <li> <p>Initialization (Automatic): <code>MotionSystemCore</code> automatically loads <code>default_physics.tres</code> and passes the <code>PhysicsConfig</code> instance to this system via <code>set_physics_config</code>. The system then populates its internal <code>_registered_materials</code> dictionary.</p> </li> <li> <p>Determine Material Type: The colliding entity (e.g., <code>PlayerCharacter</code>) or <code>CollisionMotionResolver</code> determines the name (\"default\", \"ice\", etc.) of the material involved in the collision (usually based on the collider's properties or metadata).</p> </li> <li> <p>Query Properties: The system needing the properties (typically <code>CollisionMotionResolver</code>) gets this subsystem and queries it:     <pre><code># Example within CollisionMotionResolver._create_impact_surface_data\nvar collision_material_system = _core.get_subsystem(\"CollisionMaterialSystem\")\nvar material_type = collision_info.get(\"material\", \"default\") # Get material name\nvar elasticity = 0.5 # Fallback\nvar friction = 0.3 # Fallback\n\nif collision_material_system:\n    var material_properties = collision_material_system.get_material_properties(material_type)\n    elasticity = material_properties.get(\"bounce\", elasticity)\n    friction = material_properties.get(\"friction\", friction)\n\nvar surface_data = ImpactSurfaceData.new(normal, elasticity, friction)\n</code></pre></p> </li> </ol>"},{"location":"motion/collision_material_system/#extending-with-new-material-types","title":"Extending with New Material Types","text":"<p>To add a new material type (e.g., \"sand\"):</p> <ol> <li>Add Properties to <code>PhysicsConfig.gd</code>: <pre><code>@export var sand_material_friction: float = 0.7\n@export var sand_material_bounce: float = 0.4\n</code></pre></li> <li>Add Values to <code>default_physics.tres</code>: <pre><code>[resource]\n# ... other properties ...\nsand_material_friction = 0.7\nsand_material_bounce = 0.4\n</code></pre></li> <li>Update <code>CollisionMaterialSystem._update_materials_from_config</code>: Add an entry for the new material type:     <pre><code>_registered_materials[\"sand\"] = {\n    \"friction\": _physics_config.get_param(\"sand_material_friction\", \"default\") if _physics_config else SAND_FRICTION, # Define SAND_FRICTION constant for fallback\n    \"bounce\": _physics_config.get_param(\"sand_material_bounce\", \"default\") if _physics_config else SAND_BOUNCE, # Define SAND_BOUNCE constant for fallback\n    \"sound\": \"sand_impact\" # Add appropriate sound key\n}\n</code></pre></li> <li>Update Collision Detection: Ensure your game logic correctly identifies \"sand\" materials during collisions and includes <code>\"material\": \"sand\"</code> in the <code>collision_info</code> dictionary passed to the <code>MotionSystem</code>.</li> </ol>"},{"location":"motion/collision_materials/","title":"Collision Materials","text":""},{"location":"motion/collision_materials/#collision-materials-system","title":"Collision Materials System","text":"<p>This system provides a way to define and detect different material types for collision surfaces in the game. It affects physics properties like friction and bounce, as well as sound effects when collisions occur.</p>"},{"location":"motion/collision_materials/#overview","title":"Overview","text":"<p>The Collision Materials System consists of:</p> <ol> <li>CollisionMaterialSystem: A subsystem of the MotionSystem that manages material properties and provides modifiers for collision events.</li> <li>MaterialType: A component that can be attached to objects to explicitly define their material type.</li> <li>DefaultMaterial: A base implementation that provides default material properties.</li> </ol>"},{"location":"motion/collision_materials/#how-to-use","title":"How to Use","text":""},{"location":"motion/collision_materials/#defining-material-types","title":"Defining Material Types","text":"<p>There are several ways to define the material type of an object:</p> <ol> <li> <p>Attach a MaterialType component (recommended):    <pre><code># In the editor, add a MaterialType node to your object\n# Or in code:\nvar material_type = MaterialType.new()\nmaterial_type.material_type = \"ice\"\nyour_node.add_child(material_type)\n</code></pre></p> </li> <li> <p>Set the material_type property:    <pre><code>your_node.material_type = \"mud\"\n</code></pre></p> </li> <li> <p>Add the node to a material group:    <pre><code>your_node.add_to_group(\"rubber\")\n</code></pre></p> </li> <li> <p>Implement a get_material_type method:    <pre><code>func get_material_type() -&gt; String:\n    return \"ice\"\n</code></pre></p> </li> </ol>"},{"location":"motion/collision_materials/#available-material-types","title":"Available Material Types","text":"<p>The system comes with these predefined material types:</p> <ul> <li>default: Standard surface with moderate friction and bounce.</li> <li>ice: Slippery surface with low friction and high bounce.</li> <li>mud: Sticky surface with high friction and low bounce.</li> <li>rubber: Bouncy surface with high friction and very high bounce.</li> </ul>"},{"location":"motion/collision_materials/#registering-custom-materials","title":"Registering Custom Materials","text":"<p>You can register custom material types with the CollisionMaterialSystem:</p> <pre><code>var collision_material_system = motion_system.get_subsystem(\"CollisionMaterialSystem\")\ncollision_material_system.register_material(\"metal\", {\n    \"friction\": 0.3,\n    \"bounce\": 0.7,\n    \"sound\": \"metal_impact\"\n})\n</code></pre>"},{"location":"motion/collision_materials/#material-detection","title":"Material Detection","text":"<p>When a collision occurs, the system detects the material type in this order:</p> <ol> <li>Check if the material is already specified in the collision info.</li> <li>Check if the collider has a <code>material_type</code> property.</li> <li>Check if the collider has a <code>collision_material</code> property.</li> <li>Check if the collider is in a material group (e.g., \"ice\", \"mud\").</li> <li>Check if the collider has a <code>get_material_type()</code> method.</li> <li>Check the collider's name for material hints (least reliable).</li> <li>Fallback to \"default\" if no material is detected.</li> </ol>"},{"location":"motion/collision_materials/#integration-with-physics","title":"Integration with Physics","text":"<p>The CollisionMaterialSystem provides modifiers for the MotionSystem that affect:</p> <ul> <li>Friction: How quickly an object slows down when sliding.</li> <li>Bounce: How much energy is preserved when bouncing off a surface.</li> <li>Sound: What sound effect to play on impact.</li> </ul> <p>These properties are loaded from the PhysicsConfig resource, with fallbacks to default values if the config is missing.</p>"},{"location":"motion/collision_materials/#best-practices","title":"Best Practices","text":"<ol> <li>Use the MaterialType component for explicit material definition.</li> <li>Avoid relying on node names for material detection.</li> <li>Register custom materials at startup for consistency.</li> <li>Use the CollisionMaterialSystem's API for material detection rather than implementing your own.</li> </ol>"},{"location":"motion/launch_system/","title":"Launch System","text":""},{"location":"motion/launch_system/#modularlaunchsystem","title":"ModularLaunchSystem","text":"<p>A subsystem for the MotionSystem that handles entity launching and trajectory prediction.</p>"},{"location":"motion/launch_system/#overview","title":"Overview","text":"<p>The LaunchSystem provides a centralized way to handle launching entities with specific angles, powers, and strengths. It also includes trajectory prediction for UI visualization.</p>"},{"location":"motion/launch_system/#components","title":"Components","text":"<ul> <li>LaunchSystem.gd (ModularLaunchSystem): Main entry point that implements IMotionSubsystem</li> <li>LaunchCalculator.gd: Handles launch vector calculations</li> <li>TrajectoryPredictor.gd: Generates trajectory preview points</li> <li>LaunchEntityData.gd: Manages entity-specific launch data</li> </ul>"},{"location":"motion/launch_system/#usage","title":"Usage","text":""},{"location":"motion/launch_system/#entity-registration","title":"Entity Registration","text":"<p>Before using the LaunchSystem, you need to register entities:</p> <pre><code>var entity_id = my_entity.get_instance_id()\nlaunch_system.register_entity(entity_id)\n</code></pre>"},{"location":"motion/launch_system/#setting-launch-parameters","title":"Setting Launch Parameters","text":"<pre><code># Set launch parameters (angle in degrees, power from 0.0 to 1.0, optional strength)\nlaunch_system.set_launch_parameters(entity_id, 45.0, 0.8, 1500.0)\n</code></pre>"},{"location":"motion/launch_system/#launching-an-entity","title":"Launching an Entity","text":"<pre><code># Launch with current parameters\nvar launch_vector = launch_system.launch_entity(entity_id, entity_position)\n\n# Or launch with specific parameters\nvar launch_vector = launch_system.launch_entity_with_parameters(entity_id, 45.0, 0.8, 1500.0, entity_position)\n</code></pre>"},{"location":"motion/launch_system/#trajectory-prediction","title":"Trajectory Prediction","text":"<pre><code># Get trajectory points for UI visualization\nvar trajectory_points = launch_system.get_preview_trajectory(entity_id)\n</code></pre>"},{"location":"motion/launch_system/#signal-connections","title":"Signal Connections","text":"<p>The LaunchSystem emits the <code>entity_launched</code> signal when an entity is launched:</p> <p>```gdscript</p>"},{"location":"motion/launch_system/#connect-to-the-entity_launched-signal","title":"Connect to the entity_launched signal","text":"<p>launch_system.entity_launched.connect(func(entity_id, launch_vector, position):      print(\"Entity \" + str(entity_id) + \" launched with vector \" + str(launch_vector) + \" at position \" + str(position)) )</p>"},{"location":"motion/obstacle_system/","title":"Obstacle System","text":""},{"location":"motion/obstacle_system/#obstacle-system","title":"Obstacle System","text":"<p>The Obstacle System is responsible for handling interactions between the player and obstacles in the game. It modifies player motion based on obstacle types and configurations.</p>"},{"location":"motion/obstacle_system/#core-architecture","title":"Core Architecture","text":"<p>The Obstacle System follows a modular, component-based design with clear separation of concerns:</p> <ol> <li>ObstacleSystem: Main entry point that implements IMotionSubsystem</li> <li>ObstacleTypeRegistry: Manages registration of different obstacle types</li> <li>ObstacleCalculator: Combines effects from multiple obstacle types</li> <li>Obstacle Types: Individual effect implementations (Weakener, Deflector, etc.)</li> <li>Data Classes: Context and outcome objects for passing data between components</li> </ol>"},{"location":"motion/obstacle_system/#obstacle-types","title":"Obstacle Types","text":"<p>The system supports multiple obstacle types, each with a specific motion-altering effect:</p> <ul> <li>Weakener: Reduces motion strength (velocity multiplier)</li> <li>Deflector: Redirects trajectory (angle modification)</li> <li>Stopper: (Future) Cancels all motion</li> <li>Dragger: (Future) Applies drag over time</li> <li>Scrambler: (Future) Adds unpredictability</li> <li>Flipper: (Future) Transforms motion shape</li> </ul>"},{"location":"motion/obstacle_system/#creating-obstacles","title":"Creating Obstacles","text":""},{"location":"motion/obstacle_system/#1-create-configuration-resources","title":"1. Create Configuration Resources","text":"<p>Create resource files for each obstacle type you want to use:</p> <pre><code># WeakenerConfig.tres\nextends Resource\nclass_name WeakenerConfig\n\n@export var velocity_multiplier: float = 0.6\n@export var apply_to_x: bool = true\n@export var apply_to_y: bool = true\n</code></pre> <pre><code># DeflectorConfig.tres\nextends Resource\nclass_name DeflectorConfig\n\n@export var deflect_angle: float = 15.0\n@export var angle_variance: float = 5.0\n@export var trigger_direction: String = \"top\"\n</code></pre>"},{"location":"motion/obstacle_system/#2-create-obstacle-script","title":"2. Create Obstacle Script","text":"<p>Create a script for your obstacle that implements the required methods:</p> <pre><code>extends Node2D\n\n@export var weakener_config: WeakenerConfig\n@export var deflector_config: DeflectorConfig\n\nfunc get_obstacle_types() -&gt; Array:\n    return [\"weakener\", \"deflector\"]\n\nfunc get_obstacle_config() -&gt; Dictionary:\n    var config = {}\n\n    # Add weakener config\n    config[\"weakener\"] = {\n        \"velocity_multiplier\": weakener_config.velocity_multiplier,\n        \"apply_to_x\": weakener_config.apply_to_x,\n        \"apply_to_y\": weakener_config.apply_to_y\n    }\n\n    # Add deflector config\n    config[\"deflector\"] = {\n        \"deflect_angle\": deflector_config.deflect_angle,\n        \"angle_variance\": deflector_config.angle_variance,\n        \"trigger_direction\": deflector_config.trigger_direction\n    }\n\n    return config\n</code></pre>"},{"location":"motion/obstacle_system/#3-create-obstacle-scene","title":"3. Create Obstacle Scene","text":"<p>Create a scene with: - StaticBody2D as the root node - CollisionShape2D for physics - Sprite2D for visuals - Add to the \"obstacles\" group - Attach your obstacle script - Assign configuration resources</p>"},{"location":"motion/obstacle_system/#integration-with-motion-system","title":"Integration with Motion System","text":"<p>The ObstacleSystem integrates with the MotionSystem through the IMotionSubsystem interface:</p> <ol> <li>Register the ObstacleSystem with the MotionSystemCore</li> <li>The ObstacleSystem will process collisions with obstacles</li> <li>Motion modifiers will be applied based on obstacle effects</li> </ol>"},{"location":"motion/obstacle_system/#signals","title":"Signals","text":"<p>The ObstacleSystem emits the following signals:</p> <ul> <li><code>obstacle_hit(entity_id, obstacle_name, resulting_velocity)</code>: When an entity collides with an obstacle</li> <li><code>near_miss(entity_id, obstacle_name, distance)</code>: When an entity passes close to an obstacle without colliding</li> </ul>"},{"location":"motion/obstacle_system/#example-usage","title":"Example Usage","text":"<pre><code># In your game initialization code\nvar obstacle_system = ObstacleSystem.new()\nmotion_system_core.register_subsystem(obstacle_system)\n\n# Connect to signals if needed\nobstacle_system.obstacle_hit.connect(_on_obstacle_hit)\nobstacle_system.near_miss.connect(_on_near_miss)\n</code></pre>"},{"location":"motion/obstacle_system/#adding-new-obstacle-types","title":"Adding New Obstacle Types","text":"<p>To add a new obstacle type:</p> <ol> <li>Create a new script extending RefCounted that implements:</li> <li><code>apply_effect(context, config) -&gt; Vector2</code></li> <li><code>can_affect(context, config) -&gt; bool</code></li> <li><code>get_debug_info(context, config, result_velocity) -&gt; String</code></li> <li> <p><code>get_type_name() -&gt; String</code></p> </li> <li> <p>Register the type with the ObstacleTypeRegistry:    <pre><code>var my_type = MyObstacleType.new()\nobstacle_type_registry.register_obstacle_type(\"my_type\", my_type)\n</code></pre></p> </li> <li> <p>Create a configuration resource for the type</p> </li> <li> <p>Update obstacle scripts to include the new type in <code>get_obstacle_types()</code> and <code>get_obstacle_config()</code></p> </li> </ol>"},{"location":"motion/obstacle_system/#testing","title":"Testing","text":"<p>The ObstacleSystem includes a test scene and script to verify functionality:</p> <ul> <li><code>ObstacleTestScene.tscn</code>: A scene with a player and a RockObstacle</li> <li><code>test_obstacle_system.gd</code>: A script that runs tests on the ObstacleSystem</li> </ul> <p>Run the test scene to verify that the ObstacleSystem is working correctly.</p>"},{"location":"motion/overview/","title":"Overview","text":""},{"location":"motion/overview/#motion-system","title":"Motion System","text":"<p>The Motion System is responsible for handling all physics and movement-related functionality in the game. It provides a framework for calculating motion, resolving collisions, and applying various motion modifiers.</p>"},{"location":"motion/overview/#architecture","title":"Architecture","text":"<p>The Motion System follows a layered architecture with a facade pattern:</p> <pre><code>graph TD\n    MotionSystem[MotionSystem] --&gt; MotionSystemCore\n    MotionSystemCore --&gt; PhysicsCalculator\n    MotionSystemCore --&gt; MotionStateManager\n    MotionSystemCore --&gt; ContinuousMotionResolver\n    MotionSystemCore --&gt; CollisionMotionResolver\n    MotionSystemCore --&gt; MotionProfileResolver\n\n    MotionSystemCore --&gt; Subsystems\n\n    Subsystems --&gt; BounceSystem\n    Subsystems --&gt; BoostSystem\n    Subsystems --&gt; LaunchSystem\n    Subsystems --&gt; ObstacleSystem\n    Subsystems --&gt; CollisionMaterialSystem\n\n    MotionProfileResolver --&gt; PhysicsConfig\n    MotionProfileResolver --&gt; GroundPhysicsConfig</code></pre>"},{"location":"motion/overview/#core-components","title":"Core Components","text":"<ol> <li>MotionSystem (<code>MotionSystem.gd</code>): </li> <li>Facade that provides a simplified interface to the rest of the game</li> <li> <p>Delegates most calls to the MotionSystemCore</p> </li> <li> <p>MotionSystemCore (<code>MotionSystemCore.gd</code>): </p> </li> <li>Central component that manages subsystems and coordinates motion resolution</li> <li>Handles subsystem registration and signal connections</li> <li> <p>Orchestrates the motion resolution process</p> </li> <li> <p>Motion Resolvers:</p> </li> <li>ContinuousMotionResolver: Handles frame-by-frame motion (gravity, friction, etc.)</li> <li>CollisionMotionResolver: Handles collision responses (bounces, slides, etc.)</li> <li> <p>MotionProfileResolver: Resolves motion parameters based on context (biome, etc.)</p> </li> <li> <p>Support Components:</p> </li> <li>PhysicsCalculator: Performs physics calculations</li> <li>MotionStateManager: Manages motion state transitions</li> </ol>"},{"location":"motion/overview/#subsystems","title":"Subsystems","text":"<p>The Motion System uses a subsystem architecture to allow for modular extension of functionality:</p> <ul> <li>BounceSystem: Handles bounce physics and effects</li> <li>BoostSystem: Handles player-initiated boosts</li> <li>LaunchSystem: Handles launching the player</li> <li>ObstacleSystem: Handles interactions with obstacles</li> <li>CollisionMaterialSystem: Handles material-specific collision responses</li> </ul> <p>Each subsystem implements the <code>IMotionSubsystem</code> interface and can provide modifiers that affect motion calculations.</p>"},{"location":"motion/overview/#configuration","title":"Configuration","text":"<p>The Motion System is configured through several resource files:</p> <ul> <li>PhysicsConfig (<code>resources/physics/default_physics.tres</code>): Global physics parameters</li> <li>GroundPhysicsConfig (<code>resources/motion/profiles/ground/*.tres</code>): Biome-specific ground physics</li> </ul>"},{"location":"motion/overview/#physics-resolution-architecture","title":"Physics Resolution Architecture","text":"<p>The Motion System uses a layered approach to resolve physics parameters, allowing different sources to influence the final behavior in a predictable, priority-based manner.</p>"},{"location":"motion/overview/#layered-resolution-model","title":"Layered Resolution Model","text":"<pre><code>graph TD\n    A[MotionProfileResolver] --&gt; B[Layer 4: Global Physics Config]\n    A --&gt; C[Layer 3: Biome/Ground Physics]\n    A --&gt; D[Layer 2: Equipment + Traits]\n    A --&gt; E[Layer 1: Temporary Modifiers]\n\n    F[Player] --&gt; |Context| A\n    A --&gt; |Resolved Profile| F</code></pre> <p>Physics parameters are resolved by applying configurations in reverse priority order (lowest priority first):</p> <ol> <li>Layer 4: Global Physics Config</li> <li>Source: <code>PhysicsConfig</code> (<code>resources/physics/default_physics.tres</code>)</li> <li>Purpose: Defines baseline physics parameters for the entire game</li> <li> <p>Examples: Bounce thresholds, material properties, boost strengths</p> </li> <li> <p>Layer 3: Biome/Ground Physics</p> </li> <li>Source: <code>GroundPhysicsConfig</code> (<code>resources/motion/profiles/ground/{biome_id}_ground.tres</code>)</li> <li>Purpose: Defines environment-specific physics modifications</li> <li>Examples: Ice has low friction, mud has high drag</li> <li> <p>Future: May expand to include air physics, water physics, etc.</p> </li> <li> <p>Layer 2: Equipment + Traits (Planned)</p> </li> <li>Source: Future <code>EquipmentProfile</code> and <code>TraitProfile</code> resources</li> <li>Purpose: Defines character-specific physics modifications</li> <li> <p>Examples: Ice boots increase friction on ice, lightweight trait reduces gravity</p> </li> <li> <p>Layer 1: Temporary Modifiers (Planned)</p> </li> <li>Source: Status effects, powerups, environmental conditions</li> <li>Purpose: Defines temporary physics modifications</li> <li>Examples: Speed boost, slowing effect, wind gust</li> </ol>"},{"location":"motion/overview/#resolution-process","title":"Resolution Process","text":"<p>The <code>MotionProfileResolver.resolve_motion_profile()</code> method:</p> <ol> <li>Starts with default values for all parameters</li> <li>Applies each configuration layer in sequence</li> <li>Later layers can override values from earlier layers</li> <li>Tracks the source of each parameter for debugging</li> <li>Returns a complete profile with all resolved parameters</li> </ol>"},{"location":"motion/overview/#biome-and-equipment-interaction","title":"Biome and Equipment Interaction","text":"<p>This layered approach enables sophisticated interactions between biomes and character equipment:</p> <pre><code># Example scenario: Player with ice boots in a mud biome\n\n# Layer 4: Global Physics (baseline values)\n# friction = 0.2 (default)\n\n# Layer 3: Mud Biome (environment-specific)\n# friction = 0.4 (high friction from mud)\n\n# Layer 2: Ice Boots (character-specific)\n# friction = 0.1 (low friction from boots)\n\n# Result: friction = 0.1 (equipment overrides biome)\n</code></pre> <p>This allows for gameplay mechanics like: - Equipment that counters specific biome challenges - Traits that provide advantages in certain environments - Specialized gear for different environmental conditions</p>"},{"location":"motion/overview/#implementation-status","title":"Implementation Status","text":"<ul> <li>Implemented: Layers 4 (Global) and 3 (Biome)</li> <li>Planned: Layers 2 (Equipment/Traits) and 1 (Temporary)</li> </ul>"},{"location":"motion/overview/#extending-the-system","title":"Extending the System","text":"<p>To add new configuration sources:</p> <ol> <li>Define a new config class (e.g., <code>AirPhysicsConfig</code>)</li> <li>Add a member variable in <code>MotionProfileResolver</code> (e.g., <code>_air_config</code>)</li> <li>Create a setter method (e.g., <code>set_air_config()</code>)</li> <li>Add a loading method (e.g., <code>update_air_config_for_biome()</code>)</li> <li>Update the <code>resolve_motion_profile()</code> method to apply the new config</li> <li>Create resource files (e.g., <code>default_air.tres</code>, <code>forest_air.tres</code>)</li> </ol>"},{"location":"motion/overview/#debugging","title":"Debugging","text":"<p>The system tracks the source of each parameter, allowing you to see which layer provided each value:</p> <pre><code># Enable debug output\nmotion_profile_resolver.set_debug_enabled(true)\n\n# Output example:\n# MotionProfileResolver: Resolved profile for player 12345:\n#   - friction: 0.100 (equipment)\n#   - bounce: 0.800 (default)\n#   - drag: 0.300 (ground)\n</code></pre> <p>This helps diagnose unexpected behavior and verify that overrides are working correctly.</p>"},{"location":"motion/overview/#usage","title":"Usage","text":""},{"location":"motion/overview/#integrating-with-player-character","title":"Integrating with Player Character","text":"<p>The player character interacts with the Motion System through several methods:</p> <pre><code># In _physics_process\nvar motion_context = {\n    \"entity_id\": entity_id,\n    \"entity_type\": \"player\",\n    \"player_node\": self,\n    \"position\": position,\n    \"velocity\": velocity,\n    \"delta\": delta,\n    # ... other context data\n}\n\n# Resolve frame motion\nvar motion_result = motion_system.resolve_frame_motion(motion_context)\n\n# Apply results\nvelocity = motion_result.velocity\nhas_launched = motion_result.has_launched\nis_sliding = motion_result.is_sliding\n\n# Handle collisions\nvar collision_info = {\n    \"entity_id\": entity_id,\n    \"position\": position,\n    \"normal\": collision.get_normal(),\n    \"velocity\": velocity_before_slide,\n    \"material\": material_type,\n    # ... other collision data\n}\n\nvar collision_result = motion_system.resolve_collision(collision_info)\n</code></pre>"},{"location":"motion/overview/#creating-a-new-subsystem","title":"Creating a New Subsystem","text":"<p>To create a new motion subsystem:</p> <ol> <li>Create a new script that extends <code>RefCounted</code> and implements the <code>IMotionSubsystem</code> interface:</li> </ol> <pre><code>class_name MyNewSubsystem\nextends RefCounted\n\n# Reference to the motion system\nvar _motion_system = null\n\n# Return the subsystem name\nfunc get_name() -&gt; String:\n    return \"MyNewSubsystem\"\n\n# Called when the subsystem is registered\nfunc on_register() -&gt; void:\n    pass\n\n# Called when the subsystem is unregistered\nfunc on_unregister() -&gt; void:\n    pass\n\n# Return modifiers for continuous motion\nfunc get_continuous_modifiers(delta: float) -&gt; Array:\n    var modifiers = []\n    # Add modifiers here\n    return modifiers\n\n# Return modifiers for collision events\nfunc get_collision_modifiers(collision_info: Dictionary) -&gt; Array:\n    var modifiers = []\n    # Add modifiers here\n    return modifiers\n\n# Optional: Return signal dependencies\nfunc get_signal_dependencies() -&gt; Array:\n    return [\n        {\n            \"provider\": \"LaunchSystem\",\n            \"signal_name\": \"entity_launched\",\n            \"method\": \"_on_entity_launched\"\n        }\n    ]\n</code></pre> <ol> <li>Add the subsystem path to <code>_subsystem_paths</code> in <code>MotionSystemCore.gd</code>:</li> </ol> <pre><code>var _subsystem_paths = [\n    # ... existing subsystems\n    \"res://scripts/motion/subsystems/my_new_subsystem/MyNewSubsystem.gd\"\n]\n</code></pre>"},{"location":"motion/overview/#motion-modifiers","title":"Motion Modifiers","text":"<p>Motion modifiers are used to affect motion calculations. They can be created using the <code>MotionModifier</code> class:</p> <pre><code>var modifier = MotionModifier.new(\n    \"MyNewSubsystem\",  # source\n    \"friction\",        # type\n    10,                # priority\n    Vector2(0, 0),     # vector (no direction change)\n    0.5,               # scalar (e.g., friction value)\n    false,             # is_additive (replace or add)\n    1.0                # duration (in seconds, -1 for permanent)\n)\n</code></pre>"},{"location":"motion/overview/#debugging_1","title":"Debugging","text":"<p>The Motion System includes debugging functionality that can be enabled:</p> <pre><code>motion_system.set_debug_enabled(true)\n</code></pre> <p>This will output detailed information about motion calculations, subsystem registration, and more.</p>"},{"location":"motion/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Use the Facade: Always interact with the Motion System through the <code>MotionSystem</code> facade, not directly with <code>MotionSystemCore</code>.</li> <li>Context-Rich Information: Provide as much context as possible in motion and collision info dictionaries.</li> <li>Subsystem Independence: Design subsystems to be independent of each other. Use signal dependencies for communication.</li> <li>Profile-Based Configuration: Use the <code>MotionProfileResolver</code> for context-specific motion parameters rather than hardcoding values.</li> <li>Error Handling: Check return values and handle errors gracefully.</li> </ol>"},{"location":"motion/overview/#potential-expansions","title":"Potential Expansions","text":"<p>The Motion System is designed to be extensible. Here are some potential expansions that could be implemented in the future:</p>"},{"location":"motion/overview/#player-status-modifier-system","title":"Player Status Modifier System","text":"<p>A subsystem for managing temporary status modifiers that affect player attributes and behavior.</p> <p>Features: - Manages temporary status modifiers with durations (shields, invincibility, speed boosts, slowing effects) - Applies and removes modifiers based on their lifetime - Provides motion modifiers that affect player movement and behavior</p> <p>Implementation: 1. Create a <code>PlayerStatusModifierSystem</code> class implementing the <code>IMotionSubsystem</code> interface 2. Define specific modifier types in a dedicated directory (e.g., <code>scripts/player_status_modifiers/</code>) 3. Implement an interface for status modifiers (e.g., <code>IPlayerStatusModifier</code>) 4. Register the system in <code>MotionSystemCore.gd</code></p> <p>Example Usage: <pre><code>var status_system = motion_system.get_subsystem(\"PlayerStatusModifierSystem\")\nif status_system:\n    status_system.apply_modifier(\"shield\", 10.0, 1.0) # Apply shield for 10 seconds at full strength\n</code></pre></p>"},{"location":"motion/overview/#other-potential-subsystems","title":"Other Potential Subsystems","text":"<ul> <li>EquipmentSystem: Handle equipment that affects player movement</li> <li>TraitSystem: Manage permanent player traits that modify motion</li> <li>EnvironmentalForceSystem: Handle environmental forces like wind, currents, etc.</li> </ul>"},{"location":"player/debug/","title":"Debug","text":""},{"location":"player/debug/#movement-debug-tools","title":"Movement Debug Tools","text":"<p>This folder contains debug tools for analyzing player movement and system interactions.</p>"},{"location":"player/debug/#components","title":"Components","text":""},{"location":"player/debug/#movementdebugtools","title":"MovementDebugTools","text":"<p>A comprehensive debug component that allows you to analyze movement and system interactions with visual feedback.</p>"},{"location":"player/debug/#usage","title":"Usage","text":"<ol> <li>Add the <code>MovementDebugTools.tscn</code> scene to any node in your game scene</li> <li>Use the following keys to control debugging:</li> <li><code>B</code>: Toggle background movement (freeze/unfreeze)</li> <li><code>C</code>: Toggle camera movement (freeze/unfreeze)</li> <li><code>D</code>: Toggle debug visuals and movement logging</li> <li>Watch the status display in the top-center of the screen for current system states</li> <li>Check the console for movement logs</li> </ol>"},{"location":"player/debug/#features","title":"Features","text":"<ul> <li>Freeze/unfreeze both camera and background movement</li> <li>Visual camera bounds display (red rectangle)</li> <li>Movement logging for player and camera</li> <li>Status display showing current system states</li> <li>Debug messages in console</li> <li>Easy to add/remove for debugging sessions</li> </ul>"},{"location":"player/debug/#example","title":"Example","text":"<pre><code># Add to any node in your game scene\nvar debug_tools = load(\"res://scripts/player/debug/MovementDebugTools.tscn\").instantiate()\nadd_child(debug_tools)\n</code></pre>"},{"location":"player/debug/#debug-keys","title":"Debug Keys","text":"<ul> <li><code>B</code>: Toggle background movement (freeze/unfreeze)</li> <li><code>C</code>: Toggle camera movement (freeze/unfreeze)</li> <li><code>D</code>: Toggle debug visuals and movement logging</li> </ul>"},{"location":"player/debug/#status-display","title":"Status Display","text":"<p>The status display shows: - Current state of background movement - Current state of camera movement - Debug visuals state - Key bindings for all controls</p>"},{"location":"player/debug/#debug-visuals","title":"Debug Visuals","text":"<p>When enabled (D key): - Red rectangle showing camera bounds - Console logs showing:   - Player movement per frame   - Camera movement per frame </p>"},{"location":"stage/overview/","title":"Overview","text":""},{"location":"stage/overview/#stage-composition-system","title":"Stage Composition System","text":"<p>The Stage Composition System is responsible for dynamically generating and managing the game stage. It handles chunk creation, content distribution, and flow/difficulty adjustment based on player performance.</p>"},{"location":"stage/overview/#directory-structure","title":"Directory Structure","text":"<p>The Stage Composition System follows this directory structure:</p> <ul> <li><code>scripts/stage/</code> - Contains all GDScript (.gd) files for the Stage Composition System</li> <li><code>stage/</code> - Contains all scene (.tscn) files that use those scripts</li> </ul> <p>This separation of scripts and scenes is a standard pattern throughout the project.</p>"},{"location":"stage/overview/#architecture","title":"Architecture","text":"<p>The Stage Composition System follows a layered architecture with specialized subsystems:</p> <pre><code>graph TD\n    StageCompositionSystem[StageCompositionSystem] --&gt; StageCompositionManager\n\n    StageCompositionManager --&gt; ChunkManagementSystem\n    StageCompositionManager --&gt; ContentDistributionSystem\n    StageCompositionManager --&gt; StageConfigSystem\n    StageCompositionManager --&gt; FlowAndDifficultyController\n\n    ChunkManagementSystem -.-&gt;|request_chunk_instantiation| GlobalSignals\n    ContentDistributionSystem -.-&gt;|request_content_placement| GlobalSignals\n\n    GlobalSignals -.-&gt; ContentInstantiationService\n    ContentInstantiationService --&gt; ContentFactory</code></pre>"},{"location":"stage/overview/#core-components","title":"Core Components","text":"<ol> <li>StageCompositionSystem (<code>StageCompositionSystem.gd</code>): </li> <li>Facade that provides a simplified interface to the rest of the game</li> <li> <p>Delegates most calls to the StageCompositionManager</p> </li> <li> <p>StageCompositionManager (<code>StageCompositionManager.gd</code>): </p> </li> <li>Central component that coordinates stage generation and management</li> <li>Handles game modes (story, arcade) and stage transitions</li> <li> <p>Manages the flow and difficulty of the stage</p> </li> <li> <p>Subsystems:</p> </li> <li>ChunkManagementSystem: Manages the creation, placement, and recycling of stage chunks</li> <li>ContentDistributionSystem: Determines what content (obstacles, items, etc.) to place in each chunk</li> <li>StageConfigSystem: Loads and manages stage configuration resources</li> <li> <p>FlowAndDifficultyController: Adjusts difficulty based on player performance</p> </li> <li> <p>Content Creation:</p> </li> <li>Stage components emit signals to request content creation</li> <li><code>GlobalSignals</code> routes these requests to the <code>ContentInstantiationService</code></li> <li><code>ContentFactory</code> creates the actual content objects</li> </ol>"},{"location":"stage/overview/#stage-generation-process","title":"Stage Generation Process","text":"<p>The stage generation process follows these steps:</p> <ol> <li>A stage generation is requested with a config ID and game mode</li> <li>The <code>StageConfigSystem</code> loads the corresponding <code>StageCompositionConfig</code></li> <li>The <code>FlowAndDifficultyController</code> is initialized with the config's parameters</li> <li>The <code>ChunkManagementSystem</code> generates initial chunks</li> <li>As the player moves, new chunks are generated ahead and old ones recycled</li> <li>The <code>ContentDistributionSystem</code> populates chunks with content based on the current difficulty and flow state</li> </ol>"},{"location":"stage/overview/#configuration","title":"Configuration","text":"<p>The Stage Composition System is configured through several resource files:</p> <ul> <li>StageCompositionConfig (<code>resources/stage/configs/*.tres</code>): Defines stage parameters</li> <li>ChunkDefinition (<code>resources/stage/chunks/*.tres</code>): Defines chunk layouts</li> <li>ContentDistribution (<code>resources/stage/content_distributions/*.tres</code>): Defines content placement rules</li> </ul>"},{"location":"stage/overview/#game-modes","title":"Game Modes","text":"<p>The system supports different game modes:</p> <ol> <li>Story Mode:</li> <li>Has a defined end condition (distance or event)</li> <li>Follows a predetermined difficulty curve</li> <li> <p>Can transition to cutscenes or other stages</p> </li> <li> <p>Arcade Mode:</p> </li> <li>Potentially endless</li> <li>Dynamically adjusts difficulty based on player performance</li> <li>Can transition to other arcade stages for variety</li> </ol>"},{"location":"stage/overview/#flow-and-difficulty","title":"Flow and Difficulty","text":"<p>The <code>FlowAndDifficultyController</code> adjusts the stage difficulty based on player performance:</p> <ol> <li>Flow States:</li> <li>FLOW_EASY: Player is struggling, reduce difficulty</li> <li>FLOW_BALANCED: Player is performing as expected</li> <li> <p>FLOW_CHALLENGING: Player is excelling, increase difficulty</p> </li> <li> <p>Performance Metrics:</p> </li> <li>Speed</li> <li>Height</li> <li>Combo chains</li> <li>Obstacle avoidance</li> <li> <p>Collection rate</p> </li> <li> <p>Difficulty Adjustments:</p> </li> <li>Content density</li> <li>Obstacle complexity</li> <li>Reward placement</li> <li>Special event frequency</li> </ol>"},{"location":"stage/overview/#usage","title":"Usage","text":""},{"location":"stage/overview/#generating-a-stage","title":"Generating a Stage","text":"<p>To generate a stage:</p> <pre><code># Using the StageCompositionSystem\nstage_composition_system.generate_stage(\"default_stage\", \"story\")\n\n# Or via GlobalSignals\nvar config = stage_config_system.get_config(\"default_stage\")\nGlobalSignals.stage_generation_requested.emit(config, \"arcade\")\n</code></pre>"},{"location":"stage/overview/#updating-player-position","title":"Updating Player Position","text":"<p>The system needs to know the player's position to generate chunks ahead:</p> <pre><code># In the player's _physics_process\nstage_composition_system.update_player_position(position)\n</code></pre>"},{"location":"stage/overview/#recording-performance","title":"Recording Performance","text":"<p>To enable dynamic difficulty adjustment:</p> <pre><code># When the player performs an action\nstage_composition_system.record_performance_event(\n    FlowAndDifficultyController.PerformanceMetric.SPEED,\n    player_speed\n)\n</code></pre>"},{"location":"stage/overview/#creating-a-custom-stage","title":"Creating a Custom Stage","text":"<p>To create a custom stage:</p> <ol> <li>Create a new <code>StageCompositionConfig</code> resource</li> <li>Set the stage parameters (length, theme, difficulty, etc.)</li> <li>Define the content distribution</li> <li>Add chunk definitions</li> <li>Save the config to <code>resources/stage/configs/</code></li> </ol>"},{"location":"stage/overview/#chunk-system","title":"Chunk System","text":"<p>The chunk system is responsible for the physical layout of the stage:</p> <ol> <li>Chunk Definition:</li> <li>Defines the physical structure of a chunk</li> <li>Can include predefined platforms, obstacles, etc.</li> <li> <p>Can define marker points for dynamic content placement</p> </li> <li> <p>Chunk Management:</p> </li> <li>Chunks are instantiated ahead of the player</li> <li>Old chunks are recycled when they're far behind the player</li> <li> <p>Chunks are positioned to create a continuous stage</p> </li> <li> <p>Chunk Types:</p> </li> <li>Default Chunks: Standard chunks with basic layouts</li> <li>Random Chunks: Chunks with randomized elements</li> <li>Varied Chunks: Chunks with multiple possible configurations</li> <li>Special Chunks: Chunks for specific events or challenges</li> </ol>"},{"location":"stage/overview/#content-distribution","title":"Content Distribution","text":"<p>The content distribution system determines what content to place in each chunk:</p> <ol> <li>Content Categories:</li> <li>Obstacles: Impede player progress</li> <li>Collectibles: Provide rewards</li> <li>Power-ups: Grant temporary abilities</li> <li> <p>Decorations: Visual elements with no gameplay effect</p> </li> <li> <p>Distribution Rules:</p> </li> <li>Based on difficulty level</li> <li>Influenced by flow state</li> <li>Can be biome/theme specific</li> <li> <p>Can create patterns or sequences</p> </li> <li> <p>Placement Strategies:</p> </li> <li>Grid-based placement</li> <li>Height zone placement</li> <li>Pattern-based placement</li> <li>Random placement with constraints</li> </ol>"},{"location":"stage/overview/#analytics","title":"Analytics","text":"<p>The Stage Composition System emits analytics events to track player progress and system performance:</p> <pre><code>GlobalSignals.analytics_event.emit({\n    \"event_type\": \"stage_generated\",\n    \"stage_id\": config.id,\n    \"game_mode\": game_mode,\n    \"theme\": config.theme,\n    \"difficulty\": config.target_difficulty\n})\n</code></pre> <p>These events can be used for debugging, balancing, and player behavior analysis.</p>"},{"location":"stage/overview/#debugging","title":"Debugging","text":"<p>The system includes debugging functionality:</p> <ol> <li>Debug Overlay: Shows information about chunks, content, flow state, etc.</li> <li>Debug Methods: Methods to inspect the current state of the system</li> <li>Debug Prints: Detailed logging when debug mode is enabled</li> </ol>"},{"location":"stage/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Config-Driven Design: Use configuration resources rather than hardcoded values</li> <li>Balanced Difficulty: Ensure the difficulty curve is smooth and responsive</li> <li>Performance Optimization: Recycle chunks and content to minimize instantiation</li> <li>Visual Consistency: Coordinate with the Environment System for theme consistency</li> <li>Extensibility: Design chunk and content systems to be easily extended</li> </ol>"},{"location":"stage/overview/#system-integration","title":"System Integration","text":"<p>To integrate the Stage Composition System into a game:</p> <ol> <li>Add the StageCompositionSystem scene to your game scene</li> <li>Initialize it with the player node for tracking:    <pre><code># Set the player node for tracking\nstage_composition_system.set_player_node(player_character)\n</code></pre></li> <li>Generate a stage with the desired configuration:    <pre><code># Generate the initial stage\nstage_composition_system.generate_stage(\"default_stage\", \"story\")\n</code></pre></li> <li>Update the player position in your game loop:    <pre><code># In _process or _physics_process\nstage_composition_system.update_player_position(player_character.global_position)\n</code></pre></li> <li>Record performance metrics to enable dynamic difficulty adjustment:    <pre><code># When player collects items, hits obstacles, etc.\nstage_composition_system.record_performance_event(\n    FlowAndDifficultyController.PerformanceMetric.COLLECTIBLE_COLLECTION_RATE,\n    1.0\n)\n</code></pre></li> </ol>"},{"location":"stage/overview/#legacy-systems","title":"Legacy Systems","text":"<p>Note that the older <code>scripts/stages/StageManager.gd</code> has been removed from the project. All code should use the Stage Composition System.</p>"},{"location":"visual_background/debug/","title":"Debug","text":""},{"location":"visual_background/debug/#visual-background-debug-tools","title":"Visual Background Debug Tools","text":"<p>This folder contains debug tools for the visual background system.</p>"},{"location":"visual_background/debug/#components","title":"Components","text":""},{"location":"visual_background/debug/#backgrounddebugtools","title":"BackgroundDebugTools","text":"<p>A debug component that allows you to freeze/unfreeze background movement for debugging purposes.</p>"},{"location":"visual_background/debug/#usage","title":"Usage","text":"<ol> <li>Add the <code>BackgroundDebugTools.tscn</code> scene as a child of your <code>VisualBackgroundSystem</code> node</li> <li>Use the <code>B</code> key to toggle background movement:</li> <li>When disabled: Background position is frozen at its current position</li> <li>When enabled: Background resumes normal parallax movement</li> <li>Check the console for debug messages</li> </ol>"},{"location":"visual_background/debug/#features","title":"Features","text":"<ul> <li>Freeze/unfreeze background movement with <code>B</code> key</li> <li>Preserves background position when frozen</li> <li>Debug messages in console</li> <li>Easy to add/remove for debugging sessions</li> </ul>"},{"location":"visual_background/debug/#example","title":"Example","text":"<pre><code># Add to VisualBackgroundSystem node\nvar debug_tools = load(\"res://visual_background/debug/BackgroundDebugTools.tscn\").instantiate()\nadd_child(debug_tools)\n</code></pre>"},{"location":"visual_background/debug/#debug-keys","title":"Debug Keys","text":"<ul> <li><code>B</code>: Toggle background movement (freeze/unfreeze) </li> </ul>"},{"location":"visual_background/overview/","title":"Overview","text":""},{"location":"visual_background/overview/#visual-background-system","title":"Visual Background System","text":""},{"location":"visual_background/overview/#overview","title":"Overview","text":"<p>The Visual Background System provides a modular, data-driven parallax background architecture for the game. It enables dynamic, theme-based multi-layer backgrounds with performance monitoring and seamless integration with the EnvironmentSystem and CameraSystem.</p> <ul> <li>Data-driven: All background composition is defined via resource files.</li> <li>Modular: Each responsibility is encapsulated in a focused class or resource.</li> <li>Extensible: Designed for future expansion (atmospherics, transitions, cinematic props).</li> </ul>"},{"location":"visual_background/overview/#responsibilities","title":"Responsibilities","text":"<ul> <li>Orchestrate loading and switching of background themes in response to environment changes.</li> <li>Dynamically build and manage parallax layers and their visual elements.</li> <li>Integrate with camera movement for parallax scrolling.</li> <li>Monitor and warn about performance (layer count, texture memory, draw calls).</li> </ul>"},{"location":"visual_background/overview/#main-components","title":"Main Components","text":""},{"location":"visual_background/overview/#visualbackgroundsystem-node2d","title":"VisualBackgroundSystem (Node2D)","text":"<ul> <li>Entry point for the system.</li> <li>Uses configurable NodePaths to locate dependencies (EnvironmentSystem, CameraSystem).</li> <li>Listens for theme changes from <code>EnvironmentSystem</code>.</li> <li>Passes theme config to <code>ParallaxLayerController</code>.</li> <li>Receives camera updates and forwards to controller.</li> </ul>"},{"location":"visual_background/overview/#parallaxlayercontroller-parallaxbackground","title":"ParallaxLayerController (ParallaxBackground)","text":"<ul> <li>Manages creation and clearing of <code>ParallaxLayer</code> nodes.</li> <li>Instantiates and configures <code>Sprite2D</code> elements per layer.</li> <li>Handles tiling via <code>ParallaxLayer.motion_mirroring</code>, scaling, modulate, and z-index for each element.</li> <li>Tracks performance metrics and provides debug logging through the Debug system.</li> </ul>"},{"location":"visual_background/overview/#resource-types","title":"Resource Types","text":"<ul> <li>BackgroundLayerElement.gd: Defines a single visual element (texture, offset, scale, modulate, z-index).</li> <li>BackgroundLayerConfig.gd: Defines a parallax layer (parallax ratio, z-index, elements).</li> <li>EnvironmentThemeConfig.gd: Defines a full background theme (name, array of layers).</li> </ul>"},{"location":"visual_background/overview/#integration","title":"Integration","text":"<ul> <li>EnvironmentSystem: Triggers theme changes; system listens for <code>visuals_updated</code> signal.</li> <li>ThemeDatabase: Stores and provides <code>EnvironmentThemeConfig</code> resources for each theme.</li> <li>CameraSystem: Provides camera position updates for parallax effect.</li> </ul>"},{"location":"visual_background/overview/#usage","title":"Usage","text":""},{"location":"visual_background/overview/#addingmodifying-background-themes","title":"Adding/Modifying Background Themes","text":"<ol> <li>Create a new <code>.tres</code> resource using <code>EnvironmentThemeConfig.gd</code>.</li> <li>Define one or more <code>BackgroundLayerConfig</code> resources, each with an array of <code>BackgroundLayerElement</code> resources.</li> <li>Assign textures, offsets, scale, modulate, and z-index properties as needed.</li> <li>Register the new theme in <code>ThemeDatabase</code> under <code>visual_background_themes</code>.</li> </ol>"},{"location":"visual_background/overview/#adding-layers-or-elements","title":"Adding Layers or Elements","text":"<ul> <li>Add new <code>BackgroundLayerConfig</code> entries to a theme for more parallax layers.</li> <li>Add new <code>BackgroundLayerElement</code> entries to a layer for more visual elements.</li> </ul>"},{"location":"visual_background/overview/#extension-points","title":"Extension Points","text":"<ul> <li>Atmospherics/Transitions: Extend <code>BackgroundLayerConfig</code> and <code>EnvironmentThemeConfig</code> with new properties.</li> <li>Cinematic Props: Add new element types or logic in <code>ParallaxLayerController</code>.</li> <li>Performance: Adjust monitoring thresholds in <code>ParallaxLayerController</code>.</li> </ul>"},{"location":"visual_background/overview/#consistency-guidelines","title":"Consistency Guidelines","text":"<ul> <li>Keep scripts under 100-150 lines; decompose if needed.</li> <li>Each class/module has a single responsibility.</li> <li>No speculative TODOs; document only current behavior.</li> <li>Use clear, explicit logic and naming.</li> </ul>"},{"location":"visual_background/overview/#file-locations","title":"File Locations","text":"<ul> <li>System scripts: <code>visual_background/</code></li> <li>Resource scripts: <code>scripts/resources/</code></li> <li>Theme resources: <code>resources/environment/themes/</code></li> <li>Integration: <code>environment/EnvironmentSystem.tscn</code>, <code>resources/environment/ThemeDatabase.gd</code></li> </ul> <p>This documentation is up-to-date as of the latest refactoring (April 2025) and reflects the current system architecture and usage. For further details, see the code and resource files referenced above.</p>"}]}